import timeclass Joc:    NR_LINII = 2    NR_COLOANE = 6    JMIN = None    JMAX = None    GOL = '#'    def __init__(self, tabla=None, mancala_b=None, mancala_a=None):        if tabla is not None:            self.tabla = tabla            self.mancala_a = mancala_a            self.mancala_b = mancala_b        else:            self.mancala_b = 0            self.mancala_a = 0            self.tabla = []            for i in range(2):                self.tabla.append([4 for i in range(6)])    def final(self):        for i in range(2):            if self.tabla[i] == [0 for i in range(6)]:                if i == 0:                    for k in range(6):                        self.mancala_a += self.tabla[1][k]                else:                    for k in range(6):                        self.mancala_b += self.tabla[0][k]                if self.mancala_b > self.mancala_a:                    return 'b'                elif self.mancala_b < self.mancala_a:                    return 'a'                else:                    return "remiza"        return False    def get_jucator_opus(self, jucator):        if jucator == self.JMIN:            return self.JMAX        else:            return self.JMIN    def get_counter_clockwise(self):        lista_counter_clockwise = ['a']        lista_counter_clockwise.extend([[0, i] for i in range(5, -1, -1)])        lista_counter_clockwise.append('b')        lista_counter_clockwise.extend([[1, i] for i in range(6)])        return lista_counter_clockwise    def add_mancala(self, jucator, suma, mancala_b, mancala_a):        if jucator == 'b':            mancala_b[0] += suma        else:            mancala_a[0] += suma    def linie_jucator(self, jucator, i):        if jucator == 'b' and i == 0:            return True        elif jucator == 'a' and i == 1:            return True        else:            return False    def mutare(self, i, j, jucator, tabla, mancala_b, mancala_a):        lista = self.get_counter_clockwise()        index = lista.index([i, j])        din_nou = False        while tabla[i][j] != 0:            index += 1            if index == len(lista):                index = 0            casuta = lista[index]            if casuta == self.get_jucator_opus(jucator):                continue            if tabla[i][j] != 1:                if casuta == jucator:                    self.add_mancala(jucator, 1, mancala_b, mancala_a)                    tabla[i][j] -= 1                else:                    tabla[i][j] -= 1                    tabla[casuta[0]][casuta[1]] += 1            else:                if casuta == jucator:                    self.add_mancala(jucator, 1, mancala_b, mancala_a)                    tabla[i][j] -= 1                    din_nou = True                else:                    if tabla[casuta[0]][casuta[1]] == 0 and self.linie_jucator(jucator, casuta[0]) is True:                        if casuta[0] == 0:                            self.add_mancala(jucator, 1 + self.tabla[1][casuta[1]], mancala_b, mancala_a)                            tabla[1][casuta[1]] = 0                            tabla[i][j] -= 1                        else:                            self.add_mancala(jucator, 1 + self.tabla[0][casuta[1]], mancala_b, mancala_a)                            tabla[0][casuta[1]] = 0                            tabla[i][j] -= 1                    else:                        tabla[i][j] -= 1                        tabla[casuta[0]][casuta[1]] += 1        return din_nou    def mutari_joc(self, jucator):        l_mutari = []        for i in range(6):            if self.linie_jucator(jucator, i):                for j in range(6):                    aux_tabla = [x[:] for x in self.tabla]                    aux_mancala_b = [self.mancala_b]                    aux_mancala_a = [self.mancala_a]                    while self.mutare(i, j, jucator, aux_tabla, aux_mancala_b, aux_mancala_a) is True:                        temp = Joc(aux_tabla, aux_mancala_b[0], aux_mancala_a[0])                        l_mutari.extend(temp.mutari_joc(jucator))                    l_mutari.append(Joc(aux_tabla, aux_mancala_b[0], aux_mancala_a[0]))            else:                continue        return l_mutari    def estimeaza_scor(self, adancime):        t_final = self.final()        if t_final == Joc.JMAX:            return 99 + adancime        elif t_final == Joc.JMIN:            return (-99) - adancime        elif t_final == 'remiza':            return 0        else:            if self.JMAX == 'a':                return self.mancala_a - self.mancala_b            else:                return self.mancala_b - self.mancala_a    def __str__(self):        sir = ""        for i in range(6):            sir += f"   B-{i} "        sir += '\n'        for i, linie in enumerate(self.tabla):            for casuta in linie:                sir += f"   |{casuta}| "            sir += '\n'            if i == 0:                sir += f"|{self.mancala_b}|"                for j in range(38):                    sir += '-'                sir += f" |{self.mancala_a}|"                sir += '\n'        for i in range(6):            sir += f"   A-{i} "        sir += '\n'        return sirclass Stare:    """    Clasa folosita de algoritmii minimax si alpha-beta    Are ca proprietate tabla de joc    Functioneaza cu conditia ca in cadrul clasei Joc sa fie definiti JMIN si JMAX (cei doi jucatori posibili)    De asemenea cere ca in clasa Joc sa fie definita si o metoda numita mutari_joc() care ofera lista cu    configuratiile posibile in urma mutarii unui jucator    """    ADANCIME_MAX = None    def __init__(self, tabla_joc, j_curent, adancime, parinte=None, scor=None):        self.tabla_joc = tabla_joc  # un obiect de tip Joc => „tabla_joc.matr”        self.j_curent = j_curent  # simbolul jucatorului curent        # adancimea in arborele de stari        # scade cu cate o unitate din „tata” in „fiu”)        self.adancime = adancime        # scorul starii (daca e finala, adica frunza a arborelui)        # sau scorul celei mai bune stari-fiice (pentru jucatorul curent)        self.scor = scor        # lista de mutari posibile din starea curenta        self.mutari_posibile = []  # lista va contine obiecte de tip Stare        # cea mai buna mutare din lista de mutari posibile pentru jucatorul curent        self.stare_aleasa = None    def jucator_opus(self):        if self.j_curent == Joc.JMIN:            return Joc.JMAX        else:            return Joc.JMIN    def get_linie(self):        if self.j_curent == 'a':            return 1        else:            return 0    def mutari_stare(self):        l_mutari = self.tabla_joc.mutari_joc(self.j_curent)        juc_opus = self.jucator_opus()        l_stari_mutari = [Stare(mutare, juc_opus, self.adancime - 1, parinte=self) for mutare in l_mutari]        return l_stari_mutari    def mutare_jucator(self, linie, coloana, jucator):        tabla = self.tabla_joc.tabla        mancala_b = [self.tabla_joc.mancala_b]        mancala_a = [self.tabla_joc.mancala_a]        din_nou = self.tabla_joc.mutare(linie, coloana, jucator, tabla, mancala_b, mancala_a)        self.tabla_joc.mancala_b = mancala_b[0]        self.tabla_joc.mancala_a = mancala_a[0]        return din_nou    def __str__(self):        sir = str(self.tabla_joc) + "(Juc curent:" + self.j_curent + ")\n"        return sirdef min_max(stare):    # Daca am ajuns la o frunza a arborelui, adica:    # - daca am expandat arborele pana la adancimea maxima permisa    # - sau daca am ajuns intr-o configuratie finala de joc    if stare.adancime == 0 or stare.tabla_joc.final():        # calculam scorul frunzei apeland "estimeaza_scor"        stare.scor = stare.tabla_joc.estimeaza_scor(stare.adancime)        return stare    # Altfel, calculez toate mutarile posibile din starea curenta    stare.mutari_posibile = stare.mutari_stare()    # aplic algoritmul minimax pe toate mutarile posibile (calculand astfel subarborii lor)    mutari_scor = [min_max(mutare) for mutare in stare.mutari_posibile]    if stare.j_curent == Joc.JMAX:        # daca jucatorul e JMAX aleg starea-fiica cu scorul maxim        stare.stare_aleasa = max(mutari_scor, key=lambda x: x.scor)    else:        # daca jucatorul e JMIN aleg starea-fiica cu scorul minim        stare.stare_aleasa = min(mutari_scor, key=lambda x: x.scor)    # actualizez scorul „tatalui” = scorul „fiului” ales    stare.scor = stare.stare_aleasa.scor    return staredef alpha_beta(alpha, beta, stare):    # Daca am ajuns la o frunza a arborelui, adica:    # - daca am expandat arborele pana la adancimea maxima permisa    # - sau daca am ajuns intr-o configuratie finala de joc    if stare.adancime == 0 or stare.tabla_joc.final():        # calculam scorul frunzei apeland "estimeaza_scor"        stare.scor = stare.tabla_joc.estimeaza_scor(stare.adancime)        return stare    # Conditia de retezare:    if alpha >= beta:        return stare  # este intr-un interval invalid, deci nu o mai procesez    # Calculez toate mutarile posibile din starea curenta (toti „fiii”)    stare.mutari_posibile = stare.mutari_stare()    if stare.j_curent == Joc.JMAX:        scor_curent = float('-inf')  # scorul „tatalui” de tip MAX        # pentru fiecare „fiu” de tip MIN:        for mutare in stare.mutari_posibile:            # calculeaza scorul fiului curent            stare_noua = alpha_beta(alpha, beta, mutare)            # incerc sa imbunatatesc (cresc) scorul si alfa            # „tatalui” de tip MAX, folosind scorul fiului curent            if scor_curent < stare_noua.scor:                stare.stare_aleasa = stare_noua                scor_curent = stare_noua.scor            if alpha < stare_noua.scor:                alpha = stare_noua.scor                if alpha >= beta:  # verific conditia de retezare                    break  # NU se mai extind ceilalti fii de tip MIN    elif stare.j_curent == Joc.JMIN:        scor_curent = float('inf')  # scorul „tatalui” de tip MIN        # pentru fiecare „fiu” de tip MAX:        for mutare in stare.mutari_posibile:            stare_noua = alpha_beta(alpha, beta, mutare)            # incerc sa imbunatatesc (scad) scorul si beta            # „tatalui” de tip MIN, folosind scorul fiului curent            if scor_curent > stare_noua.scor:                stare.stare_aleasa = stare_noua                scor_curent = stare_noua.scor            if beta > stare_noua.scor:                beta = stare_noua.scor                if alpha >= beta:  # verific conditia de retezare                    break  # NU se mai extind ceilalti fii de tip MAX    # actualizez scorul „tatalui” = scorul „fiului” ales    stare.scor = stare.stare_aleasa.scor    return staredef afis_daca_final(stare_curenta):    final = stare_curenta.tabla_joc.final()    if final:        if final == "remiza":            print("Remiza!")            print(str(stare_curenta.tabla_joc))        else:            print("A castigat " + final)            print(str(stare_curenta.tabla_joc))        return True    return Falsedef main():    # initializare algoritm    raspuns_valid = False    while not raspuns_valid:        tip_algoritm = input("Algorimul folosit? (raspundeti cu 1 sau 2)\n 1.Minimax\n 2.Alpha-Beta\n ")        if tip_algoritm in ['1', '2']:            raspuns_valid = True        else:            print("Nu ati ales o varianta corecta.")    # initializare ADANCIME_MAX    raspuns_valid = False    while not raspuns_valid:        n = input("Adancime maxima a arborelui: ")        if n.isdigit():            Stare.ADANCIME_MAX = int(n)            raspuns_valid = True        else:            print("Trebuie sa introduceti un numar natural nenul.")    # initializare jucatori    raspuns_valid = False    while not raspuns_valid:        Joc.JMIN = input("Doriti sa jucati cu a sau cu b? ").lower()        if Joc.JMIN in ['a', 'b']:            raspuns_valid = True        else:            print("Raspunsul trebuie sa fie a sau b.")    Joc.JMAX = 'a' if Joc.JMIN == 'b' else 'b'    # initializare tabla    tabla_curenta = Joc()    print("Tabla initiala")    print(str(tabla_curenta))    # creare stare initiala    stare_curenta = Stare(tabla_curenta, 'a', Stare.ADANCIME_MAX)    while True:        if stare_curenta.j_curent == Joc.JMIN:            # muta jucatorul            linie = stare_curenta.get_linie()            raspuns_valid = False            while not raspuns_valid:                try:                    coloana = int(input("coloana="))                    if coloana in range(0, 6):                        if stare_curenta.tabla_joc.tabla[linie][coloana] != 0:                            raspuns_valid = True                        else:                            print("Pe pozitia aleasa nu se afla nicio piatra")                    else:                        print("Pozitia aleasa trebuie sa fie intre 0 si 5.")                except ValueError:                    print("Pozitia trebuie sa fie numar intreg")            # dupa iesirea din while sigur am validat coloana aleasa"            # mutam toate pietrele conform regulilor jocului            din_nou = stare_curenta.mutare_jucator(linie, coloana, stare_curenta.j_curent)            # afisarea starii jocului in urma mutarii utilizatorului            print("\nTabla dupa mutarea jucatorului")            print(str(stare_curenta))            # testez daca jocul a ajuns intr-o stare finala            # si afisez un mesaj corespunzator in caz ca da            if afis_daca_final(stare_curenta):                print(f"\nJucatorul a are {stare_curenta.tabla_joc.mancala_a},"                      f" iar b are {stare_curenta.tabla_joc.mancala_b}")                print(str(stare_curenta.tabla_joc))                break            # verific daca jucatorul poate sa mai execute inca o tura            if din_nou is True:                print("Jucatorul a pus ultima piesa in mancala sa si poate sa aleaga din nou\n")                print(str(stare_curenta))                continue            stare_curenta.j_curent = stare_curenta.jucator_opus()        # --------------------------------        else:  # jucatorul e JMAX (calculatorul)            # Mutare calculator            # preiau timpul in milisecunde de dinainte de mutare            t_inainte = int(round(time.time() * 1000))            if tip_algoritm == '1':                stare_actualizata = min_max(stare_curenta)            else:  # tip_algoritm==2                stare_actualizata = alpha_beta(-500, 500, stare_curenta)            stare_curenta.tabla_joc = stare_actualizata.stare_aleasa.tabla_joc            print("Tabla dupa mutarea calculatorului")            print(str(stare_curenta))            # preiau timpul in milisecunde de dupa mutare            t_dupa = int(round(time.time() * 1000))            print("Calculatorul a \"gandit\" timp de " + str(t_dupa - t_inainte) + " milisecunde.")            if afis_daca_final(stare_curenta):                print(f"Jucatorul a are {stare_curenta.tabla_joc.mancala_a},"                      f" iar b are {stare_curenta.tabla_joc.mancala_b}")                break            # S-a realizat o mutare. Schimb jucatorul cu cel opus            stare_curenta.j_curent = stare_curenta.jucator_opus()if __name__ == "__main__":    main()