import timeclass Joc:    NR_LINII = 2    NR_COLOANE = 6    JMIN = None    JMAX = None    def __init__(self, tabla=None, mancala_b=None, mancala_a=None):        if tabla is not None:            self.tabla = tabla            self.mancala_a = mancala_a            self.mancala_b = mancala_b        else:            # tabla initiala are 4 pietre in fiecare casuta            self.mancala_b = 0            self.mancala_a = 0            self.tabla = []            for i in range(2):                self.tabla.append([4 for i in range(6)])    def final(self):        for i in range(2):            # verificam daca o linie este goala            # toate pietrele ramase pe cealalta se duc catre celalalt jucator            if self.tabla[i] == [0 for i in range(6)]:                if i == 0:                    for k in range(6):                        self.mancala_a += self.tabla[1][k]                        self.tabla[1][k] = 0                else:                    for k in range(6):                        self.mancala_b += self.tabla[0][k]                        self.tabla[0][k] = 0                #verificam daca cine a castigat                if self.mancala_b > self.mancala_a:                    return 'b'                elif self.mancala_b < self.mancala_a:                    return 'a'                else:                    return "remiza"        return False    def get_jucator_opus(self, jucator):        if jucator == self.JMIN:            return self.JMAX        else:            return self.JMIN    def get_counter_clockwise(self):        # obtinem lista cu casutele in sens counter-clockwise        # inclusiv cu mancale        lista_counter_clockwise = ['a']        lista_counter_clockwise.extend([[0, i] for i in range(5, -1, -1)])        lista_counter_clockwise.append('b')        lista_counter_clockwise.extend([[1, i] for i in range(6)])        return lista_counter_clockwise    def add_mancala(self, jucator, suma, mancala_b, mancala_a):        # functie care ajuta sa punem pietrele in mancala potrivita        if jucator == 'b':            mancala_b[0] += suma        else:            mancala_a[0] += suma    def linie_jucator(self, jucator, i):        # verificam daca linia pe care ne aflam este a jucatorului curent        if jucator == 'b' and i == 0:            return True        elif jucator == 'a' and i == 1:            return True        else:            return False    def mutare(self, i, j, jucator, tabla, mancala_b, mancala_a):        # functia care efectueaza mutarea propriu-zisa        lista = self.get_counter_clockwise()        index = lista.index([i, j])        din_nou = False        while tabla[i][j] != 0:            # luam urmatorarea pozitie din lista            index += 1            if index == len(lista):                index = 0            casuta = lista[index]            # nu punem nimic in mancala oponentului            if casuta == self.get_jucator_opus(jucator):                continue            if tabla[i][j] != 1:                # daca nu e ultima piatra                # o punem normal in casuta                if casuta == jucator:                    self.add_mancala(jucator, 1, mancala_b, mancala_a)                    tabla[i][j] -= 1                else:                    tabla[i][j] -= 1                    tabla[casuta[0]][casuta[1]] += 1            else:                # daca este ultima piatra si pica in mancala jucatorului curent                # o adaugam si indicam ca poate sa mai joace o tura                if casuta == jucator:                    self.add_mancala(jucator, 1, mancala_b, mancala_a)                    tabla[i][j] -= 1                    din_nou = True                else:                    # verificam daca ultima piesa este intr-o casuta goala a jucatorului                    # atunci captureaza toate piesele din casuta analog a oponentului                    if tabla[casuta[0]][casuta[1]] == 0 and self.linie_jucator(jucator, casuta[0]) is True:                        if casuta[0] == 0:                            self.add_mancala(jucator, 1 + self.tabla[1][casuta[1]], mancala_b, mancala_a)                            tabla[1][casuta[1]] = 0                            tabla[i][j] -= 1                        else:                            self.add_mancala(jucator, 1 + self.tabla[0][casuta[1]], mancala_b, mancala_a)                            tabla[0][casuta[1]] = 0                            tabla[i][j] -= 1                    else:                        tabla[i][j] -= 1                        tabla[casuta[0]][casuta[1]] += 1        return din_nou    def mutari_joc(self, jucator):        l_mutari = []        for i in range(6):            if self.linie_jucator(jucator, i):                for j in range(6):                    aux_tabla = [x[:] for x in self.tabla]                    aux_mancala_b = [self.mancala_b]                    aux_mancala_a = [self.mancala_a]                    # daca mutarea ne permite sa efectuam o alta tura                    # adaugam direct rezultatele unei noi ture in l_mutari                    while self.mutare(i, j, jucator, aux_tabla, aux_mancala_b, aux_mancala_a) is True:                        temp = Joc(aux_tabla, aux_mancala_b[0], aux_mancala_a[0])                        l_mutari.extend(temp.mutari_joc(jucator))                    l_mutari.append(Joc(aux_tabla, aux_mancala_b[0], aux_mancala_a[0]))            else:                continue        return l_mutari    def estimeaza_scor(self, adancime):        t_final = self.final()        if t_final == Joc.JMAX:            return 99 + adancime        elif t_final == Joc.JMIN:            return (-99) - adancime        elif t_final == 'remiza':            return 0        else:            # prima metoda de estimare calculeaza diferenta dintre macale in momentul respectiv            if estimare == 1:                if self.JMAX == 'a':                    return self.mancala_a - self.mancala_b                else:                    return self.mancala_b - self.mancala_a            # a doua metoda foloseste diferenta dintre numarul de pietre pe fiecare linie            else:                if self.JMAX == 'a':                    return sum(self.tabla[1]) - sum(self.tabla[0])                else:                    return sum(self.tabla[0]) - sum(self.tabla[1])    def __str__(self):        sir = ""        for i in range(6):            sir += f"   B-{i} "        sir += '\n'        for i, linie in enumerate(self.tabla):            for casuta in linie:                sir += f"   |{casuta}| "            sir += '\n'            if i == 0:                sir += f"|{self.mancala_b}|"                for j in range(38):                    sir += '-'                sir += f" |{self.mancala_a}|"                sir += '\n'        for i in range(6):            sir += f"   A-{i} "        sir += '\n'        return sirclass Stare:    ADANCIME_MAX = None    def __init__(self, tabla_joc, j_curent, adancime, parinte=None, scor=None):        self.tabla_joc = tabla_joc        self.j_curent = j_curent        self.adancime = adancime        self.scor = scor        self.mutari_posibile = []        self.stare_aleasa = None    def jucator_opus(self):        if self.j_curent == Joc.JMIN:            return Joc.JMAX        else:            return Joc.JMIN    def get_linie(self):        if self.j_curent == 'a':            return 1        else:            return 0    def mutari_stare(self):        l_mutari = self.tabla_joc.mutari_joc(self.j_curent)        juc_opus = self.jucator_opus()        l_stari_mutari = [Stare(mutare, juc_opus, self.adancime - 1, parinte=self) for mutare in l_mutari]        return l_stari_mutari    def mutare_jucator(self, linie, coloana, jucator):        # functie ajutatoare pentru realizarea mutarii alese de jucator        tabla = self.tabla_joc.tabla        mancala_b = [self.tabla_joc.mancala_b]        mancala_a = [self.tabla_joc.mancala_a]        din_nou = self.tabla_joc.mutare(linie, coloana, jucator, tabla, mancala_b, mancala_a)        self.tabla_joc.mancala_b = mancala_b[0]        self.tabla_joc.mancala_a = mancala_a[0]        return din_nou    def __str__(self):        sir = str(self.tabla_joc) + "(Juc curent:" + self.j_curent + ")\n"        return sirdef min_max(stare):    if stare.adancime == 0 or stare.tabla_joc.final():        stare.scor = stare.tabla_joc.estimeaza_scor(stare.adancime)        return stare    stare.mutari_posibile = stare.mutari_stare()    mutari_scor = [min_max(mutare) for mutare in stare.mutari_posibile]    if stare.j_curent == Joc.JMAX:        stare.stare_aleasa = max(mutari_scor, key=lambda x: x.scor)    else:        stare.stare_aleasa = min(mutari_scor, key=lambda x: x.scor)    stare.scor = stare.stare_aleasa.scor    return staredef alpha_beta(alpha, beta, stare):    if stare.adancime == 0 or stare.tabla_joc.final():        stare.scor = stare.tabla_joc.estimeaza_scor(stare.adancime)        return stare    if alpha >= beta:        return stare    stare.mutari_posibile = stare.mutari_stare()    if stare.j_curent == Joc.JMAX:        scor_curent = float('-inf')        for mutare in stare.mutari_posibile:            stare_noua = alpha_beta(alpha, beta, mutare)            if scor_curent < stare_noua.scor:                stare.stare_aleasa = stare_noua                scor_curent = stare_noua.scor            if alpha < stare_noua.scor:                alpha = stare_noua.scor                if alpha >= beta:                    break    elif stare.j_curent == Joc.JMIN:        scor_curent = float('inf')        for mutare in stare.mutari_posibile:            stare_noua = alpha_beta(alpha, beta, mutare)            if scor_curent > stare_noua.scor:                stare.stare_aleasa = stare_noua                scor_curent = stare_noua.scor            if beta > stare_noua.scor:                beta = stare_noua.scor                if alpha >= beta:                    break    stare.scor = stare.stare_aleasa.scor    return staredef afis_daca_final(stare_curenta):    final = stare_curenta.tabla_joc.final()    if final:        if final == "remiza":            print("Remiza!")            print(str(stare_curenta.tabla_joc))        else:            print("A castigat " + final)            print(str(stare_curenta.tabla_joc))        return True    return Falsedef main():    # initializare algoritm    raspuns_valid = False    while not raspuns_valid:        tip_algoritm = input("Algorimul folosit? (raspundeti cu 1 sau 2)\n 1.Minimax\n 2.Alpha-Beta\n ")        if tip_algoritm in ['1', '2']:            raspuns_valid = True        else:            print("Nu ati ales o varianta corecta.")    # initializare dificultate    raspuns_valid = False    while not raspuns_valid:        n = input("Ce dificultate doriti? (raspundeti cu 1, 2 sau 3)\n 1.Usor\n 2.Mediu\n 3.Greu\n ")        if int(n) in range(1, 4):            if n == 1:                Stare.ADANCIME_MAX = 2            elif n == 2:                Stare.ADANCIME_MAX = 5            else:                Stare.ADANCIME_MAX = 8            raspuns_valid = True        else:            print("Trebuie sa introduceti un numar din cele trei")    # initializare mod de estimare scor    raspuns_valid = False    while not raspuns_valid:        n = input("Ce sa prioritizeze calculatorul?\n 1)Nr de pietre din mancala\n 2)Nr de pietre de pe linie\n ")        if int(n) in range(1, 3):            global estimare            estimare = n            raspuns_valid = True        else:            print("Trebuie sa introduceti 1 sau 2")    # initializare jucatori    raspuns_valid = False    while not raspuns_valid:        Joc.JMIN = input("Doriti sa jucati cu a sau cu b? ").lower()        if Joc.JMIN in ['a', 'b']:            raspuns_valid = True        else:            print("Raspunsul trebuie sa fie a sau b.")    Joc.JMAX = 'a' if Joc.JMIN == 'b' else 'b'    # initializare tabla si stare initiala    tabla_curenta = Joc()    print("Tabla initiala")    print(str(tabla_curenta))    stare_curenta = Stare(tabla_curenta, 'a', Stare.ADANCIME_MAX)    while True:        if stare_curenta.j_curent == Joc.JMIN:            # muta jucatorul            linie = stare_curenta.get_linie()            t_inainte = int(round(time.time() * 1000))            raspuns_valid = False            quit = False            while not raspuns_valid:                try:                    coloana = input("Coloana=")                    if coloana == "exit":                        # verificam daca jucatorul vrea sa termine jocul                        # setam variabila quit = True                        print("Jucatorul a iesit din joc\n")                        print(f"\nJucatorul a are {stare_curenta.tabla_joc.mancala_a},"                              f" iar b are {stare_curenta.tabla_joc.mancala_b}")                        quit = True                        break                    coloana = int(coloana)                    if coloana in range(0, 6):                        if stare_curenta.tabla_joc.tabla[linie][coloana] != 0:                            raspuns_valid = True                        else:                            print("Pe pozitia aleasa nu se afla nicio piatra")                    else:                        print("Pozitia aleasa trebuie sa fie intre 0 si 5.")                except ValueError:                    print("Pozitia trebuie sa fie numar intreg")            if quit is True:                break            # dupa iesirea din while sigur am validat coloana aleasa            # mutam toate pietrele conform regulilor jocului            din_nou = stare_curenta.mutare_jucator(linie, coloana, stare_curenta.j_curent)            # afisarea starii jocului in urma mutarii utilizatorului            # afisam si timpul de gandire al jucatorului            print("\nTabla dupa mutarea jucatorului")            print(str(stare_curenta))            t_dupa = int(round(time.time() * 1000))            print("Jucatorul a \"gandit\" timp de " + str(t_dupa - t_inainte) + " milisecunde.")            # testez daca jocul a ajuns intr-o stare finala            # si afisez un mesaj corespunzator in caz ca da            if afis_daca_final(stare_curenta):                print(f"\nJucatorul a are {stare_curenta.tabla_joc.mancala_a},"                      f" iar b are {stare_curenta.tabla_joc.mancala_b}")                break            # verific daca jucatorul poate sa mai execute inca o tura            if din_nou is True:                print("Jucatorul a pus ultima piesa in mancala sa si poate sa aleaga din nou\n")                print(str(stare_curenta))                continue            # daca nu schimb catre calculator            stare_curenta.j_curent = stare_curenta.jucator_opus()        # --------------------------------        else:  # jucatorul e JMAX (calculatorul)            # Mutare calculator            t_inainte = int(round(time.time() * 1000))            if tip_algoritm == '1':                stare_actualizata = min_max(stare_curenta)            else:                stare_actualizata = alpha_beta(-500, 500, stare_curenta)            stare_curenta.tabla_joc = stare_actualizata.stare_aleasa.tabla_joc            # afisam mutarea aleasa de calculator            # si timpul necesar de gandire            print("Tabla dupa mutarea calculatorului")            print(str(stare_curenta))            t_dupa = int(round(time.time() * 1000))            print("Calculatorul a \"gandit\" timp de " + str(t_dupa - t_inainte) + " milisecunde.")            # verificam daca jocul a ajuns la final            if afis_daca_final(stare_curenta):                print(f"Jucatorul a are {stare_curenta.tabla_joc.mancala_a},"                      f" iar b are {stare_curenta.tabla_joc.mancala_b}")                break            # schimbam jucatorul            stare_curenta.j_curent = stare_curenta.jucator_opus()if __name__ == "__main__":    # incepem jocul si afisam cat timp a durat in total    t_joc_inceput = int(round(time.time()))    main()    t_joc_dupa = int(round(time.time()))    print("Intregul joc de Mancala a durat " + str(t_joc_dupa - t_joc_inceput) + " secunde.")